<!doctype html>
<html>
  <head>
    <title>ClickityClack</title>
    <style type="text/css">
      #content {
        margin:25px;
      }
canvas {
    float:left;
    border:2px solid black;
}
    </style>
    <script type="text/javascript" src="mazegen.js"></script>

    <script type="text/javascript" src="three.js"></script> 
    <script type="text/javascript" src="controls/FirstPersonControls.js"></script>
    <script type="text/javascript" src="controls/TrackballControls.js"></script>
    <script type="text/javascript" src="controls/FlyControls.js"></script>
  </head>

  <body>
<script id="envvert" type="x-shader/x-vertex">
varying vec3  Normal;
varying vec3  EyeDir;
varying vec3  VecToCamera;

uniform vec3  cameraPos;

void main()
{
    gl_Position    = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    Normal         = normal;
    vec4 pos       = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    EyeDir         = position.xyz;
    VecToCamera    = position.xyz;
}   
    </script>

<script id="tryit" type="x-shader/x-fragment">
varying vec3  Normal;
varying vec3  EyeDir;
varying vec3  VecToCamera;

uniform vec3  cameraPos;
uniform samplerCube EnvMap;
uniform float timeElapsed;

const vec3 BaseColor = vec3(0.2, 0.2, 0.8);
const vec3 Xunitvec = vec3(1.0, 0.0, 0.0);
const vec3 Yunitvec = vec3(0.0, 1.0, 0.0);

void main() {
    vec3 DirToCamera = normalize(cameraPos - VecToCamera);

    vec3 nnormal = normalize(Normal);
    vec3 reflectDir = normalize(reflect(DirToCamera, nnormal));
    vec4 reflectedColor = textureCube( EnvMap, DirToCamera);

    gl_FragColor = mix(reflectedColor, vec4(BaseColor,1.0), 0.8);
}
</script>

    <div id="vertexShader" style="display:none">
precision mediump float;
varying vec4 vNormal;
varying float shade;
uniform float maxY;

vec4 colorAtHeight(float height) {
    vec4 result;
    vec3 color;

    color = vec3(0.0, 0.0, 0.0);
    height = clamp(height/maxY, 0.0, 1.0);
    color = color + smoothstep(-1.0, 0.01, height) * vec3(1.0, 1.0, 0.6);    // 1.0 1.0 0.6
    color = color + smoothstep(0.01, 0.3, height) * vec3(-0.8, -0.4, -0.4);  // 0.2 0.6 0.2
    color = color + smoothstep(0.3, 0.5, height) * vec3(0.0, 0.2, 0.2);      // 0.2 0.8 0.4
    color = color + smoothstep(0.5, 0.8, height) * vec3(0.0, -0.2, -0.2);    // 0.2 0.6 0.2
    color = color + smoothstep(0.8, 0.9, height) * vec3(0.5, 0.1, 0.3);      // 0.0 0.4 0.0
    color = color + smoothstep(0.9, 0.97, height) * vec3(0.3, 0.3, 0.3);  
    color = color + smoothstep(0.97, 0.99, height) * vec3(0.1, 0.1, 0.1);   
    color = color + smoothstep(0.99, 1.0, height) * vec3(0.1, 0.1, 0.1);   

    result = vec4(color, 1.0);
    return result;
}

void main() {
    gl_Position = projectionMatrix *
                  modelViewMatrix *
                  vec4(position,1.0);

    float height = position.y / 2.0;
    
    vNormal = colorAtHeight(height);

}
    </div>
    <div id="fragmentShader" style="display:none;">

precision mediump float;
varying vec4 vNormal;

    void main() {

        gl_FragColor = vNormal;

    }
    </div>
    <div id="content">

      <canvas id="c" width="600" height="600" ></canvas>
      <div id="debug"></div>

      <script type="text/javascript">
        var canvas = document.getElementById("c");
        var start = false;
        var end = false;

        var m = initMaze(canvas);
        var c = undefined;
        var drawing = false;
        var showThing = function(evt) {
            if (m.cells[Math.floor(evt.layerX / resolution)]) {
                c = m.cells[Math.floor(evt.layerX / resolution)][Math.floor(evt.layerY/resolution)];
                if (c) {
                    //document.getElementById("debug").innerHTML = "(" + c.x + ", " + c.y + ") " + "[" + c.walls + "] " + m.getNeighbors(c, true, true).map(function(a) {return "("+ a.x + "," +a.y +")" });
                    
                }
            }
            
        };

canvas.addEventListener("mousemove", showThing);
canvas.addEventListener("mousedown", function(evt) { 
    if (!c) return;
    if (!start) {
        start = c;
        c.color = "green";
        c.draw();
    } else {
        if (!end) {
            end = c;
            c.color = "red";
            c.draw();
        } 
        
    }

} );

canvas.addEventListener("mouseup", function(evt) { 
    if (start && end) {
        m.clear();
        var path = as_path(m, start, end, true);
        var p = path[0];
        var shades = path[1];
        for (var i in p) {
            var c = p[i];
            c.color = "#f00";
            c.draw();
        }
        start = false; 
        end = false; 
        make3d(shades);
    }} );

var scene = new THREE.Scene(); 
var camera = new THREE.PerspectiveCamera(75, 1, 0.1, 5000);  
var renderer = new THREE.WebGLRenderer(); 
var controls;
var cubes = [];
var clock = new THREE.Clock();
var controls;
var mirrorCubeCamera, mirrorCube;
var plane;
var rtTexture;
var composer;
var planeMaterial;
var renderTarget;

var alight = new THREE.DirectionalLight(0xffffff, 1);
alight.position.set(15, 20, 10);
scene.add(alight);
initScene();
var size = 600;

function initScene() {
    var size = 600;
    renderer.setSize(600, 600);    
    document.body.appendChild(renderer.domElement);

    controls = new THREE.FlyControls( camera );
    controls.movementSpeed=size/5;
    //controls.lookSpeed = 0.1;
    controls.rollSpeed = 1;
    controls.dragToLook = true;
    
    camera.position.x = 0;
    camera.position.y = size/2;
    camera.position.z = size/2;

    camera.lookAt(new THREE.Vector3(0, 0, 0));

    controls.domElement = renderer.domElement;

    mirrorCubeCamera = new THREE.CubeCamera(0.1, 500, 100, 1024);
    var cubeGeom = new THREE.CubeGeometry(600, 50, 600, 1,1,1);
    mirrorCube = new THREE.Mesh( cubeGeom, mirrorCubeMaterial);
    mirrorCube.position.set(0,250,0);



    var mirrorCubeMaterial = new THREE.MeshBasicMaterial( { envMap: mirrorCubeCamera.renderTarget } );
    mirrorCubeMaterial.doubleSided = true;

    mirrorCubeCamera.position = mirrorCube.position;
    scene.add(mirrorCubeCamera);
    renderTarget = new THREE.WebGLRenderTarget(512, 512, {format:THREE.RGBFormat});

    planeMaterial = new THREE.ShaderMaterial({
        envMap: renderTarget,
        uniforms: { 
            "cameraPos" : { type: "v3", value: THREE.Vector3(camera.position.x, camera.position.y, camera.position.z) },
            "timeElapsed": {type:"f", value:0.0},
            "EnvMap" : { type: "t", value: renderTarget }},
        vertexShader: document.getElementById("envvert").textContent,
        fragmentShader: document.getElementById("tryit").textContent,
    });

    // planeMaterial = new THREE.MeshLambertMaterial({
    //     color:0x2222ff, 
    //     refraction:0.95, 
    //     envMap:mirrorCubeCamera.renderTarget});
//    plane = new THREE.Mesh(new THREE.CubeGeometry(size, 2.0, size, 1, 1, 1), planeMaterial);
    plane = new THREE.Mesh(new THREE.CubeGeometry(size, 2.0, size, 1, 1, 1), 
                          new THREE.MeshBasicMaterial({ map: renderTarget}));
    plane.rotation.x = Math.PI;
    plane.position.y = -2.0;
        
    scene.add(plane);
}



function make3d(shades) {

    while (cubes.length > 0) {
        scene.remove(cubes.pop());
    }
    

    var maxpath = shades.map(function(i) { return i.pathlen }).reduce(function(a, b) { return a > b ? a : b; });
    var merged = new THREE.CubeGeometry(0,0,0);
    var maxY = 0.1;
    for (var c in shades) {
        var cell = shades[c].cell;

        var col = shades[c].pathlen / maxpath;
        var x = 40+Math.floor((shades[c].pathlen / maxpath) * 180);

        var geometry = new THREE.CubeGeometry(1,1,1);

        var cube = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial());
        
        var cellscale = resolution;
        cube.position.x = cell.x * cellscale - size/2;
        cube.position.z = cell.y * cellscale - size/2;
        cube.position.y = (1-(shades[c].pathlen/maxpath))*10*cellscale;

        cube.scale.x = cellscale;
        cube.scale.z = cellscale;
        cube.scale.y = 2*cube.position.y;
        if (col > maxY) {
            maxY = cube.position.y;
        }
        if (merged == false) {
            console.log("here");

            merged = cube.geometry;
        } else {
            THREE.GeometryUtils.merge(merged, cube);
        }
        cubes.push(cube);
    }

    var mm = new THREE.Mesh(merged, new THREE.ShaderMaterial({
        vertexColors:THREE.VertexColors,
        uniforms:{'maxY': {type:'f', value: maxY}},
        vertexShader:document.getElementById('vertexShader').innerHTML,
        fragmentShader:document.getElementById('fragmentShader').innerHTML,

    }));
    scene.add(mm);
}
    function render() { 
        requestAnimationFrame(render);

        plane.visible = false;
        mirrorCubeCamera.updateCubeMap(renderer, scene);
        plane.visible = true;

        planeMaterial.uniforms.cameraPos.value = camera.position;


        controls.update(clock.getDelta());  
        renderer.render(scene, camera, renderTarget, true);
        planeMaterial.uniforms.EnvMap.value = renderTarget;
        renderer.render(scene, camera);
        
  
    } 
    render();
var cb = m.cells.length - 1;
var cbd = Math.floor(cb / 2);
    make3d(as_path(m, m.cells[cbd][cbd],m.cells[cbd+10][cbd+20],  true)[1]);
      </script>
    </div>
  </body>
</html>
