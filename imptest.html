<!doctype html>
<html>
  <head>
    <title>ClickityClack</title>
    <style type="text/css">
      #content {
        margin:25px;
      }
canvas {
    float:left;
    border:2px solid black;
}
    </style>
    <script type="text/javascript" src="mazegen.js"></script>

    <script type="text/javascript" src="three.js"></script> 
    <script type="text/javascript" src="controls/FirstPersonControls.js"></script>
    <script type="text/javascript" src="controls/TrackballControls.js"></script>
    <script type="text/javascript" src="controls/FlyControls.js"></script>
  </head>

  <body>
    <div id="vertexShader" style="display:none">
precision mediump float;
varying vec4 vNormal;
uniform float maxY;

vec4 colorAtHeight(float height) {
    vec4 result;
    vec3 color;

    color = vec3(0.0, 0.0, 0.0);
    height = clamp(height/maxY, 0.0, 1.0);
    color = color + smoothstep(-1.0, 0.01, height) * vec3(1.0, 1.0, 0.6);   
    color = color + smoothstep(0.01, 0.3, height) * vec3(-0.8, -0.4, -0.4); 
    color = color + smoothstep(0.3, 0.5, height) * vec3(-0.2, 0.2, -0.2); 
    color = color + smoothstep(0.5, 0.9, height) * vec3(0.0, -0.2, -0.2); 
    color = color + smoothstep(0.9, 0.97, height) * vec3(0.9, 0.3, 0.9);  
    color = color + smoothstep(0.97, 1.0, height) * vec3(0.1, 0.1, 0.1);   

    result = vec4(color, 1.0);
    return result;
}

void main() {
    gl_Position = projectionMatrix *
                  modelViewMatrix *
                  vec4(position,1.0);

    float height = position.y / 2.0;
    
    vNormal = colorAtHeight(height);

}
    </div>
    <div id="fragmentShader" style="display:none;">

precision mediump float;
varying vec4 vNormal;

    void main() {

        gl_FragColor = vNormal;

    }
    </div>
    <div id="content">

      <canvas id="c" width="600" height="600" ></canvas>
      <div id="debug"></div>

      <script type="text/javascript">
        var canvas = document.getElementById("c");
        var start = false;
        var end = false;

        var m = initMaze(canvas);
        var c = undefined;
        var drawing = false;
        var showThing = function(evt) {
            if (m.cells[Math.floor(evt.layerX / resolution)]) {
                c = m.cells[Math.floor(evt.layerX / resolution)][Math.floor(evt.layerY/resolution)];
                if (c) {
                    //document.getElementById("debug").innerHTML = "(" + c.x + ", " + c.y + ") " + "[" + c.walls + "] " + m.getNeighbors(c, true, true).map(function(a) {return "("+ a.x + "," +a.y +")" });
                    
                }
            }
            
        };

canvas.addEventListener("mousemove", showThing);
canvas.addEventListener("mousedown", function(evt) { 
    if (!c) return;
    if (!start) {
        start = c;
        c.color = "green";
        c.draw();
    } else {
        if (!end) {
            end = c;
            c.color = "red";
            c.draw();
        } 
        
    }

} );

canvas.addEventListener("mouseup", function(evt) { 
    if (start && end) {
        m.clear();
        var path = as_path(m, start, end, true);
        var p = path[0];
        var shades = path[1];
        for (var i in p) {
            var c = p[i];
            c.color = "#f00";
            c.draw();
        }
        start = false; 
        end = false; 
        make3d(shades);
    }} );

var scene = new THREE.Scene(); 
var camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);  
var renderer = new THREE.WebGLRenderer({ antialias: true}); 
var controls;
var cubes = [];
var clock = new THREE.Clock();
var controls;

var plane;

var alight = new THREE.DirectionalLight(0xffffff, 1);
alight.position.set(15, 20, 10);
scene.add(alight);
initScene();

function initScene() {
    
    renderer.setSize(600, 600);    
    document.body.appendChild(renderer.domElement);

    controls = new THREE.FlyControls( camera );
    controls.movementSpeed=10;
    //controls.lookSpeed = 0.1;
    controls.rollSpeed = 1;
    controls.dragToLook = true;
    
    camera.position.x = 30;
    camera.position.y = 35;
    camera.position.z = 100;

    camera.lookAt(new THREE.Vector3(30, 0, 30));
    camera.rotation.z = -90 * Math.PI / 180;    
    controls.domElement = renderer.domElement;

    mirrorCubeCamera = new THREE.CubeCamera( 0.1, 5000, 512 );    
    scene.add( mirrorCubeCamera );

    var mirrorCubeMaterial = new THREE.MeshBasicMaterial( { envMap: mirrorCubeCamera.renderTarget } );
    plane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshPhongMaterial({color:0x0000ff}));

    plane.rotation.x = -90 * Math.PI / 180;
   
    plane.position.y = -1;

        
    scene.add(plane);
}



function make3d(shades) {

    while (cubes.length > 0) {
        scene.remove(cubes.pop());
    }
    

    var maxpath = shades.map(function(i) { return i.pathlen }).reduce(function(a, b) { return a > b ? a : b; });
    var merged = new THREE.CubeGeometry(0,0,0);
    var maxY = 0.1;
    for (var c in shades) {
        var cell = shades[c].cell;

        var col = shades[c].pathlen / maxpath;
        var x = 40+Math.floor((shades[c].pathlen / maxpath) * 180);

        var tcol = new THREE.Color();
        //tcol.r = Math.floor(x*0.2;
        //tcol.g = Math.floor(x*0.9);
        //tcol.b = x*0.4;
        tcol.setRGB(x, x, x);
        var color = 0x11cc55;
        if (col > 0.95) {
            color = 0xffff00;
        } else if (col > 0.6) {
            color = 0x11cc55;
        } else if (col > 0.3) {
            color = 0x009922;
        } else if (col > 0.1) {
            color = 0x005500;
        } else if (col > 0.05) {
            color = 0xcccccc;
        } else {
            color = 0xffffff;
        }
        
        var material = new THREE.MeshLambertMaterial({color: color}); 
        var geometry = new THREE.CubeGeometry(1,1,1);

        var cube = new THREE.Mesh(geometry, material);
        
        var cellscale = 0.75;
        cube.position.x = cell.x * cellscale;
        cube.position.z = cell.y * cellscale;
        cube.position.y = ((1-shades[c].pathlen/maxpath))*10*cellscale;

        cube.scale.x = cellscale;
        cube.scale.z = cellscale;
        cube.scale.y = (1-shades[c].pathlen/maxpath)*20*cellscale;
        if (cube.position.y > maxY) {
            maxY = cube.position.y;
        }
        if (merged == false) {
            console.log("here");

            merged = cube.geometry;
        } else {
            THREE.GeometryUtils.merge(merged, cube);
            //Console(merged, cube.geometry);
                
        }
        //scene.add(cube);
        cubes.push(cube);

    }

    var mm = new THREE.Mesh(merged, new THREE.ShaderMaterial({
        vertexColors:THREE.VertexColors,
        uniforms:{'maxY': {type:'f', value: maxY}},
        vertexShader:document.getElementById('vertexShader').innerHTML,
        fragmentShader:document.getElementById('fragmentShader').innerHTML
    }));
    mm.overdraw = true;
    scene.add(mm);
    console.log(mm);
}
    function render() { 
        requestAnimationFrame(render);
        // plane.visible = false;
	// mirrorCubeCamera.updateCubeMap( renderer, scene );
	// plane.visible = true;

        renderer.render(scene, camera); 
        if (controls) {
            controls.update(clock.getDelta());
        } else {
            console.log(camera.position);
        }
    } 
    render();
var cb = m.cells.length - 1;
var cbd = Math.floor(cb / 4);
    make3d(as_path(m, m.cells[2*cbd][2*cbd],m.cells[cbd][cbd],  true)[1]);
      </script>
    </div>
  </body>
</html>
